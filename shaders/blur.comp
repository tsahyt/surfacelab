#version 460

layout(local_size_x = 64) in;

layout(constant_id = 0) const uint PASS_DIRECTION = 0;

const uint PASS_ROW = 0;
const uint PASS_COLUMN = 1;

layout(set = 0, binding = 0) uniform Params {
    uint quality;
    float sigma;
};

const uint OCCUPANCY_UNOCCUPIED = 2;

layout(set = 0, binding = 1) uniform Occupancy {
    uint occ_in;
    uint occ_mask;
};

layout(set = 0, binding = 2) uniform texture2D t_In;
layout(set = 0, binding = 3) uniform texture2D t_Mask;
layout(set = 0, binding = 4) uniform sampler Sampler;
layout(set = 0, binding = 5, rgba16f) uniform image2D t_Tmp1;
layout(set = 0, binding = 6, rgba16f) uniform image2D t_Tmp2;
layout(set = 0, binding = 7, rgba16f) uniform image2D t_Out;

// Return the box size for a given sigma.
int box_size(float sigma) {
    sigma *= imageSize(t_Out).x / 1024.;
    float n = quality * 2 + 1;
    float w_exact = sqrt(4 * sigma * sigma / n + 1.0);
    int w = int(floor(w_exact));
    if(w % 2 == 0) { w--; };
    return w;
}

float norm_pdf(float x, float sigma)
{
    return 0.39894 * exp(- 0.5 * x * x / (sigma * sigma)) / sigma;
}

void row_passes_fixed() {
    ivec2 resolution = imageSize(t_Out);
    int y = int(gl_GlobalInvocationID.x);
    int r = (box_size(sigma) - 1) / 2;
    vec4 c = vec4(0.);

    // Pass 1, t_In -> t_Tmp1, sampled
    for(int k = -r; k < r + 1; k++) {
        ivec2 idx = ivec2(k, y);
        vec2 uv = vec2(float(idx.x) / float(resolution.x), float(idx.y) / float(resolution.y));

        c += texture(sampler2D(t_In, Sampler), uv);
    }

    for(int x = 0; x < imageSize(t_Tmp1).x; ++x) {
        ivec2 idx = ivec2(x + r + 1, y);
        vec2 uv = vec2(float(idx.x) / float(resolution.x), float(idx.y) / float(resolution.y));
        c += texture(sampler2D(t_In, Sampler), uv);

        idx = ivec2(x - r, y);
        uv = vec2(float(idx.x) / float(resolution.x), float(idx.y) / float(resolution.y));
        c -= texture(sampler2D(t_In, Sampler), uv);

        imageStore(t_Tmp1, ivec2(x, y), c / (r + r + 1));
    }

    for(uint q = 0; q < quality; ++q) {
        // Pass 2, t_Tmp1 -> t_Tmp2
        c = vec4(0.);
        for(int k = -r; k < r + 1; k++) {
            ivec2 idx = ivec2(k, y) % imageSize(t_Tmp1);
            c += imageLoad(t_Tmp1, idx);
        }

        for(int x = 0; x < imageSize(t_Tmp2).x; ++x) {
            ivec2 idx = ivec2(x + r + 1, y) % imageSize(t_Tmp1);
            c += imageLoad(t_Tmp1, idx);
            idx = ivec2(x - r, y) % imageSize(t_Tmp1);
            c -= imageLoad(t_Tmp1, idx);

            imageStore(t_Tmp2, ivec2(x, y), c / (r + r + 1));
        }

        // Pass 3, t_Tmp2 -> t_Tmp1
        c = vec4(0.);
        for(int k = -r; k < r + 1; k++) {
            ivec2 idx = ivec2(k, y) % imageSize(t_Tmp2);
            c += imageLoad(t_Tmp2, idx);
        }

        for(int x = 0; x < imageSize(t_Tmp1).x; ++x) {
            ivec2 idx = ivec2(x + r + 1, y) % imageSize(t_Tmp2);
            c += imageLoad(t_Tmp2, idx);
            idx = ivec2(x - r, y) % imageSize(t_Tmp2);
            c -= imageLoad(t_Tmp2, idx);

            imageStore(t_Tmp1, ivec2(x, y), c / (r + r + 1));
        }
    }
}

void row_passes_variable() {
    ivec2 resolution = imageSize(t_Out);
    int y = int(gl_GlobalInvocationID.x);

    for(int x = 0; x < resolution.x; ++x) {
        vec4 c = vec4(0.);
        float z = 0.;
        vec2 uv = vec2(x, y) / vec2(resolution);
        float m = texture(sampler2D(t_Mask, Sampler), uv).r;

        for(int r = 0; r <= 30; ++r) {
            float weight = norm_pdf(float(r), m * sigma);
            c += weight * texture(sampler2D(t_In, Sampler), vec2(x + r, y) / vec2(resolution));
            c += weight * texture(sampler2D(t_In, Sampler), vec2(x - r, y) / vec2(resolution));
            z += weight;
        }

        imageStore(t_Tmp1, ivec2(x, y), c / (2. * z));
    }
}

void column_passes_fixed() {
    int x = int(gl_GlobalInvocationID.x);
    int r = (box_size(sigma) - 1) / 2;
    vec4 c = vec4(0.);

    for(uint q = 0; q < quality; ++q) {
        // Pass 1, t_Tmp1 -> t_Tmp2
        for(int k = -r; k < r + 1; k++) {
            ivec2 idx = ivec2(x, k) % imageSize(t_Tmp1);
            c += imageLoad(t_Tmp1, idx);
        }

        for(int y = 0; y < imageSize(t_Tmp2).y; ++y) {
            ivec2 idx = ivec2(x, y + r + 1) % imageSize(t_Tmp1);
            c += imageLoad(t_Tmp1, idx);
            idx = ivec2(x, y - r) % imageSize(t_Tmp1);
            c -= imageLoad(t_Tmp1, idx);

            imageStore(t_Tmp2, ivec2(x, y), c / (r + r + 1));
        }

        // Pass 2, t_Tmp2 -> t_Tmp1
        c = vec4(0.);
        for(int k = -r; k < r + 1; k++) {
            ivec2 idx = ivec2(x, k) % imageSize(t_Tmp2);
            c += imageLoad(t_Tmp2, idx);
        }

        for(int y = 0; y < imageSize(t_Tmp1).y; ++y) {
            ivec2 idx = ivec2(x, y + r + 1) % imageSize(t_Tmp2);
            c += imageLoad(t_Tmp2, idx);
            idx = ivec2(x, y - r) % imageSize(t_Tmp2);
            c -= imageLoad(t_Tmp2, idx);

            imageStore(t_Tmp1, ivec2(x, y), c / (r + r + 1));
        }
    }

    // Pass 3, t_Tmp1 -> t_Out
    c = vec4(0.);
    for(int k = -r; k < r + 1; k++) {
        ivec2 idx = ivec2(x, k) % imageSize(t_Tmp1);
        c += imageLoad(t_Tmp1, idx);
    }

    for(int y = 0; y < imageSize(t_Out).y; ++y) {
        ivec2 idx = ivec2(x, y + r + 1) % imageSize(t_Tmp1);
        c += imageLoad(t_Tmp1, idx);
        idx = ivec2(x, y - r) % imageSize(t_Tmp1);
        c -= imageLoad(t_Tmp1, idx);

        imageStore(t_Out, ivec2(x, y), c / (r + r + 1));
    }
}

void column_passes_variable() {
    ivec2 resolution = imageSize(t_Out);
    int x = int(gl_GlobalInvocationID.x);

    for(int y = 0; y < resolution.y; ++y) {
        vec4 c = vec4(0.);
        float z = 0.;
        vec2 uv = vec2(x, y) / vec2(resolution);
        float m = texture(sampler2D(t_Mask, Sampler), uv).r;

        for(int r = 0; r <= 30; ++r) {
            float weight = norm_pdf(float(r), m * sigma);
            c += weight * imageLoad(t_Tmp1, ivec2(x, y + r) % resolution);
            c += weight * imageLoad(t_Tmp1, ivec2(x, y - r) % resolution);
            z += weight;
        }

        imageStore(t_Out, ivec2(x, y), c / (2. * z));
    }
}

// Perform the row passes on the intermediate image, i.e. blurring with constant y
void row_passes() {
    switch(occ_mask) {
        case OCCUPANCY_UNOCCUPIED:
            row_passes_fixed();
            break;
        default:
            row_passes_variable();
    }
}

// Perform the column passes on the intermediate image, i.e. blurring with constant x.
void column_passes() {
    switch(occ_mask) {
        case OCCUPANCY_UNOCCUPIED:
            column_passes_fixed();
            break;
        default:
            column_passes_variable();
    }
}

void main() {
    switch(PASS_DIRECTION) {
        case 0:
            row_passes();
            return;
        case 1:
            column_passes();
            return;
    }
}
